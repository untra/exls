defmodule ExLS.LanguageServer.BuildError do
  @moduledoc """
  Manages errors and warnings generated by builds

  We can ascertain warnings from a captured build log using a regex, and we can determine
  errors from exceptions generated during compile. Unfortunately, these warnings and errors don't
  specify which tokens pertain to the error or warning, and some don't even specify the line number.
  We use several regexes to guess which tokens within a line are relevant based on the error
  message. This messy and prone to failure, in which case we highlight the entire line
  (minus leading and trailing whitespace).

  Line numbers are 0-based.
  """

  @enforce_keys [:severity, :file, :line, :message]
  defstruct [:severity, :source, :file, :line, :message]

  @warning_regex ~r/^warning: (.+)[\n|\r\n|\r][\s]*(.+):(\d+)$/m
  @identifier_regex ~r/\"([\w\d_]+)\"/
  @function_regex ~r/(\S+)\/\d+/
  @guess_line_regex ~r/line:? (\d+)/
  @terminal_codes_regex ~r/\x1B\[[0-9;]*[a-zA-Z]/
  @module_regex ~r/\bmodule (\S+)/i
  @attr_regex ~r/\b(\@.+)\b/

  def warnings_from_log(log) do
    log = strip_terminal_codes(log)
    warnings_raw = Regex.scan(@warning_regex, log, capture: :all_but_first)
    for [message, file, line] <- warnings_raw do
      %__MODULE__{severity: :warn, message: message, line: String.to_integer(line) - 1,
        file: Path.absname(file)}
    end
  end

  def from_compile_error(compile_error, file) do
    message =
      case compile_error do
        {:failure, kind, reason, stacktrace} ->
          case reason do
            %{description: description} ->
              description
            %{message: message} ->
              message
            _ ->
              Exception.format(kind, reason, stacktrace)
          end
        _ ->
          Exception.format(:exit, compile_error, [])
      end

    line =
      case compile_error do
        {:failure, _kind, %{line: line}, _stacktrace} ->
          max(line - 1, 0)
        _ ->
          guess_line(message) || 0
      end

    %__MODULE__{
      severity: :error,
      file: Path.absname(file),
      line: line,
      message: message
    }
  end

  @doc """
  Converts a BuildError struct to the diagnostic format specified in the Language Server Protocol
  """
  def to_diagnostic(build_error, source_file) do
    severity =
      case build_error.severity do
        :error -> 1
        :warn -> 2
      end

    range = highlight_range(build_error.line, source_file, build_error.message)
    %{"message" => build_error.message, "severity" => severity, "range" => range,
      "source" => build_error.source}
  end

  ## Helpers

  defp guess_line(message) do
    case Regex.run(@guess_line_regex, message, capture: :all_but_first) do
      [line_str] -> String.to_integer(line_str) - 1
      _ -> nil
    end
  end

  defp keywords_in_message(message) do
    [@identifier_regex, @function_regex, @attr_regex, @module_regex]
    |> Enum.flat_map(fn regex ->
         Regex.scan(regex, to_string(message), capture: :all_but_first)
       end)
    |> List.flatten
  end

  # Look for clues in the error message to determine which substrings to highlight
  defp guess_highlight_range(line, line_text, message) do
    Enum.find_value(keywords_in_message(message), fn match ->
      keywords_in_line = Regex.scan(
        ~r/\b(#{Regex.escape(match)})\b/, line_text, capture: :all_but_first, return: :index
      )

      case keywords_in_line do
        [[{idx, length}]] ->
          %{"start" => %{"line" => line, "character" => idx},
            "end" => %{"line" => line, "character" => idx + length}}
        _ ->
          nil
      end
    end)
  end

  defp strip_terminal_codes(log) do
    Regex.replace(@terminal_codes_regex, log, "")
  end

  defp full_line_range(line_number, line_text) do
    start_idx = String.length(line_text) - String.length(String.trim_leading(line_text))
    length = Enum.max([String.length(String.trim(line_text)), 1])
    %{"start" => %{"line" => line_number, "character" => start_idx},
        "end" => %{"line" => line_number, "character" => start_idx + length}}
  end

  defp default_range(line_number) do
    %{"start" => %{"line" => line_number, "character" => 0},
      "end" => %{"line" => line_number, "character" => 0}}
  end

  # If the source file is not currently open, we only set the line number and ignore columns
  defp highlight_range(line_number, nil, _message) do
    default_range(line_number)
  end

  defp highlight_range(line_number, source_file, message) do
    line_text = Enum.at(ExLS.LanguageServer.SourceFile.lines(source_file), line_number)
    if line_text do
      guess_highlight_range(line_number, line_text, message) ||
        full_line_range(line_number, line_text)
    else
      default_range(line_number)
    end
  end
end
